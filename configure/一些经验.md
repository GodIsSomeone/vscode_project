### c++

#### 一个类的默认成员函数

一个空类会产生6种默认成员函数，如下：

1. 构造函数
    没啥好说的
2. 析构函数
    没啥好说的
3. 复制构造函数
    注意深拷贝和浅拷贝。当有内存的操作的时候，默认的复制构造函数会出现重复析构同一块内存的操作。  
    使用引用传递，如果不然，会重复调用复制构造函数，卡死在这里了！  

4. 重载 =

    直接复制，调用拷贝构造函数  
    > CNull cN2 = cN1; //调用了拷贝构造函数

    先声明再赋值，调用operator =  
    > CNull cN3;
    > cN3 = cN1; //调用了赋值函数

5. 重载 &
    没啥好说的
    > cout << "&cN1:" << &cN1 << endl;

6. const 重载 &
    没啥好说的
    > const CNull cN4;
    > const CNull *pcN3 = &cN4;

```
#include "master.h"

class CNull
{
    public:
    /*
    构造函数
    */
    CNull ()
    {
        cout << this << " : constructor!"<<endl;
    }

    /*
    拷贝构造函数。注意深拷贝和浅拷贝的区别。
    为了防止不经意间的拷贝构造函数，可以声明为private！
    */
    CNull(CNull &cnull)
    {
        cout << this << " : copy constructor!" << endl;
    }

    /*
    这个地方为什么要用 “&”，为了防止调用复制构造函数！ 
    */
    CNull& operator= (const CNull &cnull)
    {
        cout << this << " : operator = constructor!" << endl;
        return *this;
    }
    
    /*
    重载取地址符
    */
    CNull* operator&()
    {
        cout << this << " : operator& constructor!" << endl;
        return this;
    }

    /*
    const 重载取地址符
    */
    const CNull* operator&() const
    {
        cout << this << " : const operator& constructor!" << endl;
        return this;
    }

    /*
    析构函数
    */
    ~CNull()
    {
        cout << this << " : destructor!" << endl;
    }
};


int main()
{
    cout << "CNull cN0:" << endl;
    CNull cN0;          //构造函数

    cout << "----------------------" << endl << endl;

    cout << "CNull cN1(cN0):" << endl;
    CNull cN1(cN0);     //copy Destructor

    cout << "----------------------" << endl << endl;

    cout << "CNull cN2 = cN1:" << endl;
    CNull cN2 = cN1; //调用了拷贝构造函数

    cout << "----------------------" << endl << endl;

    cout << "CNull cN3 = cN1:" << endl;
    CNull cN3;
    cN3 = cN1; //调用了operator = 函数

    cout << "----------------------" << endl << endl;

    cout << "&cN1:" << endl;
    cout << "&cN1:" << &cN1 << endl;// 调用operator &

    cout << "----------------------" << endl  << endl;

    cout << " const CNull *pcN3 = &cN4:" << endl;
    const CNull cN4;
    const CNull *pcN3 = &cN4;    // 调用const operator &

    system("pause");
    return 0;
}
```

### linux

#### 用户态和内核态

[Linux探秘之用户态与内核态](https://www.cnblogs.com/bakari/p/5520860.html)

